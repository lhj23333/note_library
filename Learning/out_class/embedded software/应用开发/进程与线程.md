---
share_link: https://share.note.sx/una7trju#H6Seez9Hc42CDOKdkLxUNGvbJoRs6GTMJV6J2a/FGC4
share_updated: 2025-02-13T16:44:54+08:00
---
### 1. 进程与线程：

#### 1.1 定义

- 进程是资源分配的基本单位，它是程序执行时的一个实例，在程序运行时创建
- 线程是程序执行的最小单位，是进程内部的执行单元，一个进程可以包含一个或多个线程
#### 1.2  二者区别

- 地址空间：
	- 每个进程都有自己独立的虚拟地址空间，这个空间包含了进程运行所需的所有内容，例如代码段、数据段、堆栈等
	- 同一进程中的所有线程共享该进程的地址空间。所有线程都可以访问和修改同一份数据，比如全局变量、堆内存以及库函数等
		- 虽然线程共享进程的总体地址空间，但每个线程都有自己的栈空间，用来存储局部变量、函数调用信息等

> [!Tip] 服务程序中的进程与线程关系
> - 单进程多线程模型：对于大多数多线程的服务程序（如 Web 服务器、数据库等），通常都是以单个进程启动，然后在该进程内创建多个线程来处理并发
> - 在这种模型下，所有线程都共享这个进程地址空间，可以直接访问相同的数据和资源
> - 优缺点：
> 	- 线程之间通信开销小，因为数据共享是直接的，不需要额外的进程间通信（IPC）机制；资源利用率高。
> 	- 线程并发访问共享数据时容易引发同步问题,，只要由一个线程阻塞，整个进程阻塞，但当前进程阻塞并不会对其他进程产生影响

- 执行机制：
	- 每个进程都是独立的执行单元，进程的执行始于某个入口（通常是 main ( ) 或 start ( ) 函数)，进程按照顺序执行序列
		- 在单线程进程中，代码按照指令流顺序执行
		- 在多线程进程中，不同线程可以并行或交错执行
	- 线程必须依附于进程，无法独立于进程运行
		- 线程的创建、管理和销毁都由进程负责，没有进程就没有线程
		- 线程的执行控制由进程的资源调度器和操作系统线程管理机制负责控制

#### 1.3 线程与进程之间的联系：
##### 1.3.1  线程是进程的执行单位：

- 进程包含线程：进程作为资源管理的基本单元，启动时操作系统会为其分配一部分资源（包括虚拟内存空间，设备、文件等）并对其进行管理。当进程需要执行某些任务时，操作系统会为该进程创建一个或多个线程来执行这些任务
- 线程执行任务：线程是进程的执行单元，线程负责进程中的实际工作。例如，浏览器可能有一个主线程负责界面渲染，同时多个子线程负责加载页面内容。所有这些线程共享同一进程的资源，但各自执行不同的任务。
##### 1.3.2 进程负责资源管理，线程负责任务执行：

- **进程负责资源分配和管理**：进程负责分配和管理进程级的资源，如内存、文件描述符等。当操作系统创建一个进程时，它为该进程分配独立的虚拟内存空间，并管理这个进程的生命周期。进程的资源是**独立的**，因此不同进程之间的内存空间是隔离的。
- **线程执行任务并共享资源**：线程是进程内的执行单元，线程共享进程的资源，包括内存、文件描述符等。每个线程有自己独立的**栈**和**程序计数器**，但它们使用的内存区域是 **共享的**。因此，线程更适合执行并行任务，提高程序的执行效率。

#### 1.4 多进程与多线程适用场景：

- 对资源管理和保护要求高，不限制开销和效率时，使用多进程
	- 每个进程都是独立的地址空间 
	- 进程之间的通信方式、进程调度涉及资源分配以及效率
- 要求效率高，频繁切换，且资源的保护管理要求不是很高时，使用多线程
	- 线程之间共享地址空间，且线程之间调度由线程调度器直接管理
	- 当多线程模型中，当一个线程出现阻塞时，整个进程阻塞挂起
	- 多线程模型容易出现资源竞态的现象

### 2.  进程状态：

进程可以分为五个状态
- 创建状态：
	- 一个应用程序从系统上启动，首先就是进入创建状态，需要获取系统资源创建进程管理块 (PCB：Process Control Block) 完成资源分配
- 就绪状态：
	- 在创建状态完成后，进程就已经尊卑好，但未获取处理器 CPU 资源，无法运行
- 运行状态：
	- 获取处理器资源、被系统调度，开始进入运行状态。如果进程时间片用完就进入就绪状态
- 阻塞状态：
	- 在运行状态期间，如果进行阻塞操作（例如 I/O 操作），此时，进程暂时无法进行操作进入阻塞状态
- 终止状态：
	- 进程结束或被系统终止，释放进程资源

<div style = "text-align: center;">
<img src = "https://obsidian-picgo-1331635585.cos.ap-guangzhou.myqcloud.com/PicGo_pictures/20250214110247710.png" width = "500 px"/>
</div>

### 3. 创建进程方式：

- 系统初始化
- 进程在运行过程中开启子进程
- 用户交互请求
- 一个批处理作业的初始化

### 4. 进程间通信方式：

- 管道（`Pipe`）：半双工通信，数据只能单向流动并且只能在具有亲缘关系的进程间使用（父子进程）
	- 特点：速度慢，容量有限，只有父子进程能通讯
- 流管道 (`s_pipe`)：全双工（双向）传输，只能用于父子进程
- 命名管道 (`FIFO`)：具有管道具有的功能外，允许无亲缘关系进程通信
	- 特点：任何进程都能通讯，但速度慢
- 信号量 (`semophere`)：
	- 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
	- 特点：不能用来传递复杂消息，只能用来同步
- 消息队列 (`message queue`)：
	- 消息队列是由消息组成的链表，存放在内核中并由消息队列标识符标识。
	- 消息队列是消息的链接表。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。
	- 消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。
	- 特点：
		- 容量容易受系统限制，且在第一次读取时需考虑上一次没有读完数据的问题
		- 不再局限于父子进程，而允许任意进程通过共享消息队列来实现进程间通信，并由系统调用函数来实现消息发送和接收之间的同步，从而使得用户在使用消息缓冲进行通信时不再需要考虑同步问题，使用方便。
		- 但是信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合。
- 信号 (`signal`)：
	- 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。主要作为进程间以及同一进程不同线程之间的同步手段。
- 共享内存 (`shared memory`)：
	- 共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 `IPC` 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
	- 特点：利用内存缓冲区直接交换信息，无须复制，快捷，信息量大
- 套接字 (`socket`)：
	- 套接字也是一种进程间通信机制，适用于不同机器间的进程通信

### 5. 线程间同步方法：

在操作系统中，线程与进程同步是为保证多进程或多线程环境下数据的一致性、避免数据竞争和保证程序按照预定的顺序执行的重要机制

主要通过一下几种方式来实现：
- 互斥锁（`Mutex`）：
	- 互斥锁是最常见的同步机制，用于控制对共享资源的访问。当一个线程（或进程）获得互斥锁时，其他线程必须等待直到该锁被释放。（防止多个线程并发访问共享资源时引发数据竞争和冲突）
	- 特点：
		- 每个互斥锁只能被一个线程或进程拥有，其他线程（或进程）需要等待锁释放。
		- 互斥锁唯一只有一个，即一个时间点只有一个线程可以获得锁，其他线程要等待

> [!NOTE] 自旋锁（`Spinlock`）:
> - 自旋锁是一种特殊类型的互斥体。当一个线程尝试获取自旋锁时，如果锁被其他线程持有时，他会"自旋"或"忙等"，即持续检查锁的状态，而不是像常规互斥体那样直接阻塞挂起。
> - 特点：
> 	- 对于锁持有时间非常短的场景，自旋锁可以避免线程切换的开销。因为线程没有被阻塞和调度，避免了上下文切换带来的性能消耗
> 	- 如果锁的持有时间较长，线程将会消耗CPU资源进行无效的等待，浪费处理器时间，降低系统性能。
> 

- 信号量：
	- 信号量是一种技术同步机制，通常用于控制多个线程或进程对共享资源的访问。本质是一个计数器，用于表示当前可以访问某资源的线程数量
		- 二值信号量 ：
			- 值只有 0 或 1，类似于互斥锁，常用于实现互斥
		- 计数信号量 ：
			- 值为任意非负数，用于控制对多个资源的访问
	- 特点：
		- 控制多个线程并发访问共享资源
		- 比互斥锁灵活，可以限制资源的访问数
- 条件变量：
	- 条件变量用于线程间的同步，通常与互斥锁（`Mutex`）结合适用，当一个线程在执行时，如果某个条件不满足，它可以通过条条件变量进行等待，知道其他线程通知它条件已满足，可以继续执行。（例如等待任务队列不为空）
	- 特点：
		- 线程等待某个条件发生时，可以阻塞自己，直到另一个线程发出通知。
		- 通常与互斥锁结合使用，在加锁的情况下等待条件变量。
- 读写锁：
	- 读写锁是一种用于提高并发性能的锁，允许多个线程同时读共享资源，但在写共享资源是，所有线程都会被阻塞。读写锁适用于读多写少的场景，能够提高程序的并发性和性能
	- 特点：
		- 写操作的独占性可能导致写操作被延迟，特别是在读操作非常频繁的情况下。
- 事件与信号：
	- 信号是一种异步同步机制，进程或线程可以通过信号来通知其他进程或线程的某个事件的发生
	- 事件机制，则是通过等待和通知机制来实现线程间的同步



### 6. 僵尸进程、孤儿进程、守护进程

- 僵尸进程：
	- 当一个子进程执行完毕后，其退出状态会保留在内核中，直到父进程调用 `wait()`（或 `waitpid()` 等）函数读取并回收其退出状态。如果父进程没有及时回收，子进程就会在进程表中保留一个记录，称为“僵尸进程”或“僵尸状态”。该进程已经结束运行，但仍占有系统的进程表项。

> [!Tip] 僵尸进程的影响
> - 占用进程表项
> - 资源管理和系统稳定性
> - 系统监控的混淆

- 孤儿进程：
	- 当一个进程的父进程在其运行期间提前退出，该进程就成为了孤儿进程。在 Unix/Linux 系统中，孤儿进程会被系统的 init 进程接管，保证其继续正常运行。
- 守护进程：
	- 是一种在后台运行、与终端脱离联系的进程，通常用于执行系统服务、定时任务、日志记录等长期运行的工作。守护进程不受终端控制，并在系统启动时或运行时启动，持续运行。

> [!NOTE] 区分
> 一个正常运行的子进程，如果此刻子进程退出，父进程没有及时调用 `wait` 或 `waitpid` 收回子进程的系统资源，该进程就是僵尸进程，如果系统收回了，就是正常退出，如果一个正常运行的子进程，父进程退出了但是子进程还在，该进程此刻是孤儿进程，被 int 收养，如果父进程是故意被杀掉，子进程做相应处理后就是守护进程


### 7. 常见的阻塞情况以及解决方法：

#### 7.1 同步阻塞：
- 定义：
	一种进程或线程在某些情况下需要等待某些资源或条件满足才能继续执行的机制。这种机制通常涉及到某些操作或系统调用，在资源还未准备好时，当前执行的进程就会被挂起（阻塞），直到资源变得可用或某个特定条件满足时，进程才会恢复执行

常见的同步阻塞：
- 互斥锁 (`Mutex`)：在多线程程序中，如果一个线程持有了互斥锁，其他线程必须等待该锁释放后才能继续执行。互斥锁会导致线程在某些情况下被阻塞，直到锁被其他线程释放。
- 信号量 (`Semaphore`)：当信号量的值大于 0 时，线程可以继续执行，否则线程会被阻塞，直到信号量值大于 0。信号量通常用于控制对共享资源的访问数量。
- 条件变量 (`Condition Variable`)：条件变量通常与互斥锁结合使用，用于实现线程间的同步。线程可以通过条件变量等待某些条件成立（如资源可用、数据到达等）。在等待条件变量时，线程会被阻塞，直到条件满足为止。
#### 7.2 等待阻塞：
- 定义：
	当线程无法继续执行（例如等待数据，等待锁，等待信号等）时，它会主动进入到"阻塞"或"等待"状态。在这一状态下，该线程不会被操作系统调度执行，知道阻塞条件消除（例如收到所等待的时间，资源变为可用或被其他线程唤醒）
- 机制：
	操作系统会将处于阻塞状态的线程从运行列表中移除，避免不必要的 CPU 占用，一旦条件满足，操作系统将该线程放回就绪队列，由调度器选择其重新运行

常见等待阻塞：
- I/O 阻塞：
	- 线程在等待 I/O 操作完成时（例如读取磁盘、网络数据、用户输入等），如果数据尚未到达，则会进入阻塞状态。
	- 典型例子：调用 `read()`、`recv()` 等阻塞式系统调用时，若没有数据可供读取，线程就会阻塞
	- 解决方法：
		- **非阻塞 I/O**：将 I/O 操作设置为非阻塞模式，调用返回时立即告知当前没有数据，程序可继续执行其他任务。
		- **异步 I/O**：利用操作系统的异步 I/O 机制（如 Linux 的 AIO、IOCP 等），在 I/O 完成后通过回调或事件通知进行处理。
- 同步锁阻塞：
	- 当多个线程竞争同一共享数据时，为防止数据竞争，通常会采用互斥锁等同步机制
	- 如果一个线程持有锁而未及时释放。其他线程在请求锁时就会被阻塞，知道锁释放
- 条件变量等待：
	- 线程在等待某个特定条件（例如队列中有数据、任务准备就绪）时，可以利用条件变量（如 `pthread` 的 `pthread_cond_wait`）进行阻塞等待。
	- 当另一个线程修改条件并调用相应的通知函数（如 `pthread_cond_signal` 或 `pthread_cond_broadcast`）时，被阻塞的线程才会被唤醒并继续执行。
- 线程 `join` 等待：
	- 主线程或其他线程在调用 `pthread_join` 等等待某个线程结束的操作时，如果被等待的线程还未退出，则调用 `join` 的线程将阻塞，直到目标线程终止。
- 死锁问题：
	- 当两个或多个线程互相等待对方持有的资源时，就可能发生死锁，导致相关线程永久阻塞。
	- 解决方法：
		- 资源排序：规定所有线程在申请多个资源时，必须按照固定顺序获取锁，从而避免循环等待


### 8. 线程池模型：

其逻辑流程如下：
- 创建一个生产者消费者队列，作为临时资源
	- 这一步主要的目的是创建一个队列，用于管理任务的传递。生产者负责将任务添加到队列中，消费者负责从队列中取任务并执行
	- 队列通常作为线程池与任务之间的缓冲区
- 初始化一个线程池，并使其运行起来，加入任务队列取任务并执行
	- 在这一步，初始化线程池并开始分配任务给线程池中的线程。线程池中的每个线程都会从任务队列中获取任务并开始执行
- 当任务队列为空时，所有线程阻塞
	- 如果没有任务可处理，线程将会进入阻塞状态，避免资源浪费。线程池中的线程会在队列有新任务时被唤醒
- 当需向队列加入新的任务时，生产者线程获取锁，将任务挂在队列上，然后适用条件变量通知阻塞线程去执行
	- 这是一个典型的线程同步机制，当生产者线程想向队列中添加新任务时，他必须进行等待以获取任务队列锁，确保在生成者向队列中添加任务的过程中，不会有消费者线程修改队列的状态（取任务、删除任务等）
	- 当任务添加完毕后，生产者线程释放锁，并通过条件变量唤醒消费者线程，消费者线程会继续获取锁并执行任务

基于以上任务队列管理进程（线程池进程），我们可以拓展延伸到多进程架构模型

> [!NOTE] 多进程架构设计
> 在多进程系统中，我们可以设计一个任务队列管理进程，它的主要负责工作为：
> - 管理任务队列：接收新任务，存储任务，确保任务队列的线程安全
> - 任务分配与调度：当有任务到达时，它将任务分配给适当的工作进程去执行
>   
> 具体任务的处理交给工作进程来完成，这些进程通常会等待任务队列管理进程的调度指示
> 
> 系统架构组成：
> - 任务队列管理进程（调度进程）：
> 	- 负责接收用户任务请求，并将任务放入任务队列
> 	- 适用 `IPC`（如管道，消息队列，事件等）将任务分发给工作进程
> 	- 管理队列状态，确保线程安全
> - 工作进程：
> 	- 负责响应任务队列给出的任务执行
> 	- 处理具体的业务逻辑
> 	- 工作进程执行完成后，可能将处理结果返回给任务队列管理进程，或者通过 `IPC` 通知主进程处理结果
> 
> 实际应用中的延伸：
> 在实际的分布式系统中，可能还会使用负载均衡器来控制任务如何分配给不同的工作进程。对于更为复杂的任务调度系统，可能还会设计到任务优先级、失败重试、日志记录、监控与告警等更多特性

### 9.  fork 派生：

在 Linux 操作系统中，`fork()` 和 `exec()` 是两个常用的系统调用，用于进程创建和替换执行

- `fork()` 工作原理：
	当父进程调用 `fork()` 时，操作系统会创建一个新的子进程。这个子进程几乎完全复制父进程的进程映像（除了进程 ID 和部分资源等），但不是直接共享一个进程映像，而是通过一种叫做**写时复制（Copy on Write， COW）** 来避免不必要的内存复制

> [!NOTE] 进程映像与写时复制
> - 进程映像：
> 	- 正在运行的进程在内存中的镜像。它包含了进程执行所需的所有信息，包括程序代码、数据、堆栈、寄存器、内存分配、系统资源等
> 	- 进程映像是操作系统进行内存管理、调度等操作的基础。当进程被加载到内存时，操作系统会为其分配内存空间，并创建进程映像。
> 
> - 写时复制 (COW)：
> 	- 当 `fork()` 创建子进程时，父进程和子进程会有相同的进程映像（包括代码段、数据段、堆栈等）。初始时，操作系统并不会为子进程分配新的内存副本，而是让父子进程共享同一内存空间（共享内存页）。
> 		- 这种共享是通过页表来实现的，页表中保存了进程的内存映射。
> 		- 父进程和子进程都会有自己各自的页表（页表映射虚拟地址到物理地址），**操作系统会标记他们的页表项指向相同的物理内存页面，并将这些页面标记为只读。**
> 	- 直到其中一方（通常是子进程）对尝试对页面进行修改时，操作系统会通过缺页中断机制捕获该修改请求，然后执行复制操作，给正在写入进程一个独立的副本，保持父进程与子进程的内存内容独立，从而实现"写时复制"
> 		- 缺页中断：页中断是一种异常，它会在访问页面时发生，通常由两种原因触发：
> 			- 访问的页面不在进程的内存中
> 			- 进程尝试写入一个被标记为只读的页面
> 

^ad1727

- `exec()` 工作原理：
	`exec()` 系列系统调用（例如 `execvp()`、`execv()` 等）用于将当前进程的映像替换为一个新的可执行文件，新的程序将从头开始执行。
	- `exec()` 替换进程映像时，会将当前进程的内存空间清除，然后从磁盘加载新的可执行文件，替换成新的程序，进程的 `PID` (进程标识符) 保持不变，但进程的映像、执行上下文和内存布局都会发生变化
- 通过上述两个方法的结合，Linux 可以高效地创建新进程并切换到新的程序

- 应用场景：
	- 创建进程并执行新的程序：
		- 在 `Linux` 系统中，shell 程序通常使用 `fork()` 创建一个新的子进程，然后通过 `exec()` 让子进程执行用户输入的命令。例如，用户输入 `ls` 时，shell 会调用 `fork()` 创建一个子进程，然后使用 `exec()` 让该子进程执行 `ls` 命令。这样，父进程继续保持 shell 提示符，等待新的命令，而子进程执行具体的命令。
	- 管道以及重定向：
		- 在 `Linux shell` 中，`fork()` 和 `exec()` 组合经常被用来创建子进程并执行管道操作。例如，当执行 `cat file.txt | grep "pattern"` 时，父进程会 `fork()` 出两个子进程，一个执行 `cat` 命令，另一个执行 `grep` 命令。通过 `exec()`，每个子进程会加载相应的程序并替换自己的映像。
	- 程序启动与进程管理：
		- 当一个应用程序需要启动一个新的子进程来执行某些任务时，它可以首先使用 `fork()` 创建子进程，然后通过 `exec()` 加载并执行特定的任务或程序。
	- 守护进程创建