### 0. 学习资料：

- [【一文秒懂】Linux设备树详解 | Donge Blog](https://uniondong.github.io/docs/linux/linux_driver_develop_basic/%E4%B8%80%E6%96%87%E7%A7%92%E6%87%82linux%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3/)
- [设备树Device Tree详解_devicetree-CSDN博客](https://blog.csdn.net/Rank_d/article/details/106289183)


### 1. 基本概念：

设备树 (`Device Tree`）是一种用于描述硬件设备和系统结构化的数据格式
- 其基于 Linux 系统的分层设计思想，将硬件抽象描述（`device`）与内核代码分离，使得内核能够在不依赖硬件特定代码的情况下，自动识别和配置硬件（使得内核能够独立于硬件平台进行硬件配置）
	- 传统上，硬件相关的信息都是写死在内核源码中，而设备树允许硬件描述与内核代码分离，硬件描述可以通过设备树文件传递给内核，从而使得同意内核可以支持多个不同的硬件平台
	- 在同一个芯片的不同主板上，只需更换设备树文件 `.dtb` 即可实现无差异支持，而不用更换内核文件
- 设备树描述硬件的各种信息，包括设备的地址、中断、时钟、`GPIO` 等
	- 在设备树中，设备信息以树形结构存在，每个节点表示一个硬件设备，节点的属性则描述设备的具体特性
		- 节点 `Node`：每个设备在设备树中都有一个对应的节点，节点表示一个硬件设备或硬件功能模块
		- 属性 `Property`：每个节点可以由多个属性，描述设备的具体配置，包括设备的地址、中断号、时钟频率等

#### 1.2 设备树组成：

- 设备树包含设备树编译器 `DTC`（`device tree compiler`）、设备树源文件 `DTS` (`device tree source`) 和设备树二进制文件 `DTB`（`device tree blob`）组成
	- 设备树源文件（`.dts`）：设备树源文件，描述了开发板的设备信息
	- 设备树二进制文件（`.dtb`）：设备树源文件 `dts` 经过编译后生成的二进制文件
		- 内核会通过这个文件来加载硬件配置信息
	- 编译工具 （`.dtc`）：编译工具
	- 设备树头文件（`.dtsi`）：类似于 C 语言的头文件库，由于一个 `SoC` 可能对应多个设备（电路板），这些 `.dts` 文件势必包含许多共同的部分，为了进行简化并减少冗余，将 `SoC` 公用的部分或多个设备 `.dts` 中共同的部分进行提炼保存在 `.dtsi` 文件。
- 编译命令：

```shell
dtc -I dts -O dtb xxx.dtb xxx.dts 	# 将 dts 文件编译为 dtb
dtc -I dtb -O dts xxx.dts xxx.dtb	# 将 dtb 文件编译为 dts
```
#### 1.3 设备树文件加载过程：

- 设备树源文件（`.dts`）经过编译生成设备树二进制文件（`.dtb`）, 设备上电后，`Uboot` 会将设备树在内存中的地址传给内核，然后内核去解析和读取对应的硬件资源


### 2.  设备树语法

- `dts` 文件是一种 `ASCII` 文本格式的树形数据结构，其有以下特点：
	- 每个设备树文件都有一个根节点，每个设备都是一个节点
	- 节点间可以嵌套，形成父子关系，以方便进行设备间关系的描述
	- 每个设备的属性都用一组 `key-value`（键值对）来描述
	- 每个属性的描述用 `;` 结束
- 数据结构：
```
/dts-v1/;

/ {
	node1 {
		a-string-property = "A string";
		a-string-list-property = "first string", "second string";
		
		// hex is implied in byte arrays. no '0x' prefix is required
		a-byte-data-property = [01 23 34 56];
		child-node1 {
			first-child-property;
			second-child-property = <1>;
			a-string-property = "Hello world";
		};
		child-node2 {
		};
	};
	
	node2 {
		an-empty-property;
		a-cell-property = <1 2 3 4>;	// each number (cell) is a uint32
		child-node1 {
		};
	};
};
```
- 解析：
	- `dts-v1`：表示一个 `dts` 设备树文件
	- `/`：根节点
	- `node1`、`node2 `：根节点下的两个子节点
	- `child-node1` 、`child-node2` ：子节点 `node1` 下的两个子节点
	- `a-string-property = "A string"`：字符串属性
	- `a-string-list-property = "first string", "second string";`：用逗号表示字符串列表
	- `a-byte-data-property = [01 23 34 56];`：二进制数据用方括号表示
	- `a-cell-property = <1 2 3 4>`：32 bit 无符号整数，用尖括号表示


- 设备节点名：
	- 一般规定设备的节点名称不能超过 31 个字节的字符串
	- 并且设备节点书写的一般格式为 `name@address`
		- `name`：设备节点名称（必填）
		- `address`：设备地址
	- 标签设备节点命名：
		- 书写格式为： `lable: name@address`
		- 标签 `lable` 的作用是使得系统访问内核时更为高效，可以直接使用 `&lable` 来访问该节点
	- 数据结构：
```ASCII
[label:] node-name[@unit-address]{
	[properties definitions]
	[child nodes]
} 
```
- `label`：节点标签
- `node-name`：节点名称
- `unit-address`：设备地址

<div style = "text-align: center;">
<img src = "https://obsidian-picgo-1331635585.cos.ap-guangzhou.myqcloud.com/PicGo_pictures/20250220112802035.png" width = "600px"/>
</div>

- 其他节点：
- `aliases` 子节点：
	- 根设备子节点，属于一级设备子节点
		- 设备树节点有根设备节点、一级设备子节点、二级设备子节点等
	- `aliases` 节点也被称为别名节点，即可对设备节点名称进行重定义
```
/{
	aliases{
		can0 = &flexcan1;
		can1 = &flexcan2;
		gpio0 = &gpio1;
		gpio1 = &gpio2;
		...
	}
};
```

- `chosen` 子节点：
	- `chosen` 节点也属于根设备子节点
	- `chosen` 节点并不代表真正的设备，只是作为 `Uboot` 与操作系统之间传递数据的空间
	- 通常，`chosen` 节点在 `.dts` 源文件中为空，并在启动时填充

- 属性：
	- Linux 设备节点属性采用 `key-value` 键值对的方式进行描述
	- `compatible` 兼容性属性：（字符串列表）
		- 用以配置设备所需驱动
		- 属性描述格式：`manufacturer, model`
			- `manufacturer`：表示芯片厂商
			- `model`：驱动名称
	- `model` 模块属性：（字符串）
		- 用以描述设备模块信息
			- 根节点 `model` 属性用以描述开发板信息
	- `status` 节点状态属性：（字符串）
		- 用以表示节（硬件）点的状态（常用 `okay` 和 `disable`）
		- 常见状态：
			- `okay` 表示硬件正常工作
			- `disable` 表示硬件当前不可使用
			- `fail` 表示出错不可用
			- `fail-sss` 表示原因出错不可用 (`sss` 表示具体出错原因)
	- `#address-cells`：
		- 表示子节点 `reg` 属性中表示地址字段的单元个数（即字长），每个单元 32 bit
	- `#size-cells`：
		- 表示子节点 `reg` 属性中表示长度字段的单元个数，每个单元 32 bit
	- `reg`：
		- 用以描述设备地址空间资源信息，一般为某个外设的寄存器地址范围信息
		- 每个地址值都是一个或多个 32 为整数列表，称为单元格
```
reg = <address1 length1 [address2 length2] [address3 length3] ... > 
```

以 `serial` 节点为例：

```ASCII
serial@101f0000 {
	#address-cells = <1>;
	#size-cells = <1>;
	compatible = "arm,p1011";
	reg = <0x101f0000 0x1000>;
}
```
该设备被分配了一个基地址，以及被分配区域的大小
其 `#address-cells=1` 表示 `reg` 属性中描述地址字段需要 1 个 `32bit` 单元，`#size-cells=1` 表示 `reg` 属性中描述长度字段需要 2 个单元，即 `reg=<0x101f0000 0x1000>`
- `0x101f0000`：表示 `serial` 的控制器起始地址
- `0x1000`：表示 `serial` 控制器所占用的大小


### 3. 设备树的加载过程：

#### 3.1 `Uboot` 引导阶段 :

- **编译设备树文件**：
	- 首先需要将设备树源文件 `.dts` 通过设备树编译工具 `dtc` 工具编译成设备树二进制文件 `.dtb`，并将其拷贝到存储介质（例如 `SD` 卡，`NAND` 等）中
- **`Uboot` 加载 `DTB`**：
	- 在 `Uboot` 引导阶段，`Uboot` 会通过 `load` 指令或环境变量指定，将 `dtb` 二进制文件加载到内存地址中。
	- 在 `Uboot` 完成设备树加载后，设备树的地址会作为一个变量（`fdt_addr`）通过引导参数 `bootargs` 传递给内核（该地址由 `Uboot` 的环境变量来指定）
		- `bootargs` 是一串内核启动时需要的参数，包含内核的命令行选项、设备树的内存地址、根文件系统等

#### 3.2 内核启动阶段：

- **获取设备树信息**：
	- 当 `Uboot` 引导结束后，`kernel` 在第一个汇编启动文件 `head.S/head-common.S` 中，从 `ubootrags` 传递的参数提取 `dtb` 文件地址 `fdt_addr`，并完成硬件相关的初始化。
- **内核入口**：
	- CPU 跳转到 `start_kernel()` 进行执行解析引导参数，并根据 `fdt_addr` 获取 `.dtb` 的内存地址，同时将变量 `fdt` 会指向设备树的内存地址，即 `Uboot` 加载设备树文件的位置
```c
const void *fdt = (const void *)fdt_addr;
```

#### 3.3 内核解析设备树阶段：

- 设备树本质上是一个包含硬件信息的数据结构，在内核中，该数据结构被称为 `fdt_blob`，它代表了整个设备树的二进制表示形式。内核通过 `fdt_blob` 来访问设备树中各个节点及其属性
	- `fdt_blob` 并不是一个明确的结构体类型，而是用来表示设备树数据的一种抽象方式，。在内核代码中，`fdt_blob` 通常作为指向设备树二进制数据的指针来使用
	- `.dtb` 文件结构：
		- `fdt_header`：头部结构体，定义了设备树的元数据
		- `dt_struct`：包含了设备树的节点和属性信息
		- `dt_strings`：包含设备树中所有字符串 (例如，节点名、属性名等)
	- `fdt_blob` 即是指向整个设备树二进制文件（包括头部和数据结构部分）的指针。

```c
struct fdt_header{
	uint32_t magic;
	uint32_t totalsize;			// 设备树大小
	uint32_t off_dt_struct;		// 结构部分偏移
	uint32_t off_dt_strings;	// 字符串偏移
	uint32_t off_mem_rsvmap;
	uint32_t version;
	uint32_t lastcomp_version;
	uint32_t boot_cpuid_phys;
};

typedf struct fdt_header fdt_blob;
```

- 内核通过 `fdt` 指针作为接口，以 `fdt_blob` 的抽象结构体形式解析设备树。
- 内核开始解析设备树时，它会查找设备树的根节点，并解析硬件信息
	- **解析设备树头**：
		- 在内核首先会检查设备树的头部（即 `fdt_header` 结构体），确保其符合设备树的格式要求，特别是验证魔术数字、总大小、结构部分偏移等信息。
	- **调用 `of_get_flat_dt()`**：
		- 当设备树二进制文件 `.dtb` 检验有效后，内核会调用 `of_get_flat_dt` 函数从设备树内存地址中获取设备树的根节点信息，获取 `.dtb` 文件的具体内存布局，并将设备树数据存放到内核可以操作的内存区域中
	- **获取设备树根节点**：
		- 当设备树被加载到内核操作内存后，内核会使用设备树解析库（由 `fdt` 接口提供）来访问设备树节点，逐层解析每个子节点

![image.png](https://obsidian-picgo-1331635585.cos.ap-guangzhou.myqcloud.com/PicGo_pictures/20250220171217330.png)
