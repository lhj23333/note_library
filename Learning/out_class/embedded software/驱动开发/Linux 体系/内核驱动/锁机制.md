
## 0.  并发编程

### 0.0 并发编程的基本问题：

- 并发编程的核心问题在于如何安全、有效地管理多个线程和进程之间共享的资源或数据，这里面涉及到两个主要方面：
	- **互斥（Mutual Exclusion）和同步（Synchronization）** 
	- **互斥**：确保在任何时刻只有一个线程可以访问特定资源
	- **同步**：关于多线程之间操作的顺序协调



## 1. 互斥锁

### 1.0 资料参考：

- [Linux Mutex互斥锁详解 - C语言中文网](https://c.biancheng.net/view/8631.html)

### 1.1 基本概念：






## 2. 读写锁

### 2.0 资料参考：

- [【Linux 应用开发 】Linux 跨进程读写锁全解析：原理、实现与实践 - 知乎](https://zhuanlan.zhihu.com/p/675825347)

### 2.1 基本概念：

- 共享内容概述：
	- 共享内存（`Shared Memory`）是一种在多个进程间共享和传递数据的有效方法；它就像一个公共的数据存储区域，任何知道该公共区域存在的进程都可以访问和修改其中的数据
		- 共享实际上是一段可以被多个进程访问的物理内存，它是跨进程通信（`IPC`）中最快的一种方式（避免了数据复制，直接在进程间进行数据交换）
---
- 读写锁 (`Read-Write Locks`) 是一种同步机制，用于控制对共享资源的访问，特别是再数据读写操作远多于写入操作的场景，
- 读写锁分为两种类型锁：读锁（`Read Lock`）和写锁（`Write Lock`）。
	- 读锁：允许多个线程同时进行读操作
	- 写锁：仅允许一个线程进行写操作，同时阻止任何读操作
---
- 读写锁和互斥锁（`Mutexes`）
	- 读写锁：
		- 允许多个线程同时读取共享资源（读锁），写操作（写锁）独占
			- 写锁优先级通常高于读锁（避免写饥饿）
		- 分为读锁和写锁：
			- 读锁：多个线程可以同时获取读锁，适合读多写少的场景
			- 写锁：只能由一个线程获取写锁，且此时其他线程无法获取读锁或写锁
		- 提高了高并发，允许多个读者并行访问
		- 
	- 互斥锁：
		- 一次只允许一个线程访问共享资源、无论读还是写
		- 独占式访问，任何操作（`read` 或 `write`）都需要获取锁
		- 适合读写操作频率接近或写操作较多的场景

### 2.2 在共享内存中创建读写锁：

- 核心：为实现映射该共享内存的进程都可以访问和操作该读写锁，所需实现：将该锁放置在共享内存区域中
- 实现步骤：
	- 创建共享内存区域：可通过系统调用（如 `shm_open` ）实现
	- 映射共享内存到进程空间：通过 `mmap` 将共享内存映射到进程的地址空间中
	- 在共享内存中初始化读写锁：通过 `pthread_rwlock_init` 并设置锁属性为 `PTHREAD_PROCESS_SHARED`,，使得锁可在多个进程间共享

```c
    int fd = shm_open("/sharedMemory", O_CREAT | O_RDWR, 0666);     // 创建共享内存读写锁对象
    ftruncate(fd, sizeof(pthread_rwlock_t));                        // 设置共享内存大小
    pthread_rwlock_t *rwLock = mmap(NULL, sizeof(pthread_rwlock_t),
         PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);                // 将共享内存映射到进程地址空间
  
    pthread_rwlockattr_t attr;
    pthread_rwlockattr_init(&attr);
    pthread_rwlockattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);   // 设置读写锁属性为进程共享
    pthread_rwlock_init(rwLock, &attr);
```

### 2.3 读写锁基础操作：

- 请求锁：`pthread_rwlock_xxxx`

```c
pthread_rwlock_rdlock(rwLock);
pthread_rwlock_wrlock(rwLock);
```

- 释放锁：`pthread_rwlock_unlock`

```c
pthread_rwlock_unclock(rwLock);
```

### 2.4 实际应用示例：

#### 2.4.1 跨进程读写锁实现：

```c
#include <fcntl.h>
#include <sys/mman.h>
#include <pthread.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
  
struct sharedMem {
    pthread_rwlock_t rwLock;
    char data[1024];
};
  
int main(int argc, char *argv[]){
    // 创建共享内存
    int fd = shm_open("/sharedMemory", O_CREAT | O_RDWR, 0666);
    // 分配共享内存大小
    ftruncate(fd, sizeof(struct sharedMem));
  
    // 映射共享内存
    struct sharedMem *sharedMem = mmap(NULL, sizeof(struct sharedMem),
        PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
  
    // 初始化读写锁
    pthread_rwlockattr_t attr;
    pthread_rwlockattr_init(&attr);
    pthread_rwlockattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);
    pthread_rwlock_init(&sharedMem->rwLock, &attr);
  
    // 示例操作
    if (argc > 1 && strcmp(argv[1], "write") == 0) {
        // 获取写锁
        pthread_rwlock_wrlock(&sharedMem->rwLock);
        // 修改数据
        strncpy(sharedMem->data, "Hello from writer", sizeof(sharedMem->data));
        pthread_rwlock_unlock(&sharedMem->rwLock);
        printf("Data written.\n");
    } else {
        // 获取读锁
        pthread_rwlock_rdlock(&sharedMem->rwLock);
        // 读取数据
        printf("Data read: %s\n", sharedMem->data);
        pthread_rwlock_unlock(&sharedMem->rwLock);
    }
  
    pthread_rwlock_destroy(&sharedMem->rwLock);
    munmap(sharedMem, sizeof(struct sharedMem)); // 消除当前进程对该共享内存的映射
    close(fd);
    shm_unlink("/sharedMemory");
  
    return 0;
}
```

#### 2.4.2 多线程读写锁实现：

```c
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
  
int shareData = 0;          // 共享资源
pthread_rwlock_t rwLock;    // 读写锁
pthread_mutex_t mutexLock;  // 互斥锁
  
// 读锁线程函数
void *readerThread(void *arg) {
    int id = *(int *)arg;
    pthread_rwlock_rdlock(&rwLock);
    printf("Reader %d: %d\n", id, shareData);
    sleep(1);
    pthread_rwlock_unlock(&rwLock);
  
    return NULL;
}
  
// 写锁线程函数
void *writerThread(void *arg) {
    int id = *(int *)arg;
    pthread_rwlock_wrlock(&rwLock);
    shareData ++;
    printf("Writer %d: %d\n", id, shareData);
    sleep(1);
    pthread_rwlock_unlock(&rwLock); // 释放写锁
  
    return NULL;
}
  
int main() {
    pthread_t readers[5], writers[3];
    int ids[5] = {1, 2, 3, 4, 5};
    int wids[3] = {1, 2, 3};
  
    pthread_rwlock_init(&rwLock, NULL);
  
  	// 创建线程
    for(int i = 0; i < 5; i ++) {
        pthread_create(&readers[i], NULL, readerThread, &ids[i]);
    }
    for(int i = 0; i < 3; i++) {
        pthread_create(&writers[i], NULL, writerThread, &wids[i]);
    }
  
  	// 等待线程结束
    for(int i = 0; i < 3; i++) {
        pthread_join(writers[i], NULL);
    }
    for(int i = 0; i < 5; i++) {
        pthread_join(readers[i], NULL);
    }
  
  	// 销毁锁
    pthread_rwlock_destroy(&rwLock);
  
    return 0;
}
```

#### 2.4.3 跨进程读写锁同步消息传递：

```c
#include <fcntl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <pthread.h>
#include <string.h>
#include <stdio.h>
  
#define SHMNAME "/sharedMem"
#define MAX_MESSAGE_SIZE 1024
  
struct sharedMem {
    pthread_rwlock_t rwLock;
    char message[MAX_MESSAGE_SIZE];
};
  
void ss_sharedMem_init(int shmFd, struct sharedMem **shmPtr) {
    ftruncate(shmFd, sizeof(struct sharedMem));
    *shmPtr = mmap(NULL, sizeof(struct sharedMem),
         PROT_READ | PROT_WRITE, MAP_SHARED, shmFd, 0);

    pthread_rwlockattr_t attr;
    pthread_rwlockattr_init(&attr);
    pthread_rwlockattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);
    pthread_rwlock_init(&(*shmPtr)->rwLock, &attr);
}
  
void writeMessage(struct sharedMem *shmPtr, const char *message) {
    pthread_rwlock_wrlock(&shmPtr->rwLock);
    strncpy(shmPtr->message, message, MAX_MESSAGE_SIZE);
    pthread_rwlock_unlock(&shmPtr->rwLock);
}
  
void readMessage(struct sharedMem *shmPtr) {
    pthread_rwlock_rdlock(&shmPtr->rwLock);
    printf("read message: %s\n", shmPtr->message);
    pthread_rwlock_unlock(&shmPtr->rwLock);
}
  
int main() {
    // Initialize shared memory
    int shmFd = shm_open(SHMNAME, O_CREATE | O_RDWR, 0666);
    struct sharedMem *shmPtr = NULL;
    ss_sharedMem_init(shmFd, &shmPtr);
  
    // Write and read messages
    writeMessage(shmPtr, "Hello, World!");
    readMessage(shmPtr);
  
    // Cleanup
    pthread_destory(&sharedMem->rwLock);
    munmap(shmPtr, sizeof(struct sharedMem));
    close(shmFd);
    shm_unlink(SHMNAME); // 销毁该共享内存，释放系统资源
  
    return 0;
}
```

### 2.5 面临问题与解决方案：

#### 2.5.1 避免死锁：

- 死锁发生在多个进程或线程互相等待对方释放锁资源的情况下，导致系统陷入停滞
- 解决方案：
	- **锁获取顺序**: 确保所有进程或线程以相同的顺序获取锁
	- **锁超时**: 使用带有超时的锁获取方法，如 `pthread_rwlock_timedrdlock` 和 `pthread_rwlock_timedwrlock`。
	- **资源分配策略**: 采用预防策略，比如按需分配资源，避免一次性请求所有资源


> [!NOTE] 锁获取顺序
> 当多个线程或进程需要获取多个锁时，如果它们获取锁的顺序不一致，就可能发生死锁。例如：
> 
> - 线程A先获得锁1，再请求锁2；
> - 线程B先获得锁2，再请求锁1；
> - 此时A和B都在等待对方释放锁，导致死锁。
> 
> **原理：确保所有线程/进程总是以相同顺序获取锁，可以避免死锁。**
> 
> ### 为什么这样可以避免死锁？
> 
> - 假设有锁L1、L2、L3，规定所有线程必须先申请L1，再申请L2，再申请L3（编号递增）。
> - 如果线程A已经持有L1，想要L2，线程B此时只能先申请L1，不能直接申请L2或L3。
> - 这样不会出现A持有L1等L2，B持有L2等L1的循环等待。
> - 因为所有线程都严格按照同一顺序申请锁，不会形成“环形依赖”，从而避免了死锁。

#### 2.5.2 处理锁重复初始化问题：

- 在共享内存环境中，锁的重复初始化可能导致不可预测的行为。
- 解决方案：
	- **状态标记**: 在共享内存中使用一个标记来指示锁是否已经被初始化。
	- **进程间协调**: 通过进程间通信确保只有一个进程负责初始化锁。



## 3. 自旋锁





## 4. 无锁编程

### 4.0 资料参考：

- [【C/C++ 原子操作】深入浅出：从互斥锁到无锁编程的转变 - 理解C++原子操作和内存模型 - 知乎](https://zhuanlan.zhihu.com/p/677231916)

### 4.1 互斥锁的限制：

- 互斥锁（`Mutex`）是实现线程安全的常见工具。其确保在任何给定时刻，只有一个线程可以访问共享资源（例如确保数据在读取过程中，数据被其他线程修改）

> [!NOTE]
> 然而，互斥锁同样也带来了性能上的挑战；锁可能导致线程阻塞和上下文切换，这在高性能或实时系统中是不可接受的！如同心理学家Daniel Kahneman在其著作《Thinking, Fast and Slow》中所讨论的，**人类处理问题时有两种思维方式：一种是快速、直觉的；另一种是慢速、逻辑的。这可以类比到计算机系统中的线程处理：我们既需要快速响应的直觉式处理，也需要在复杂场景下的仔细考虑。** 互斥锁往往导致系统倾向于后者，从而降低了整体的效率。

- 所以在这里就引入无锁编程的概念，探讨其是如何在保持线程安全的同时，提高系统性能和响应能力

### 4.2 基本概念：

##### 4.2.1 定义：

- 无锁编程（`Lock-Free Programming`），是一种并发编程技术，不依赖于传统的锁机制（如互斥锁）来协调线程对共享资源的访问
- 在无锁编程中，线程尝试不断地执行操作，直到成功为止，而不是在无法访问资源时被阻塞

##### 4.2.2 原理和工作方式：

