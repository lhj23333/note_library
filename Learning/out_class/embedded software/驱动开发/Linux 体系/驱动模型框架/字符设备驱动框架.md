---
share_link: https://share.note.sx/brt7pqzl#cY0jpUWVjS9FdJR/DQNgxrqjqdXczRo9qBFi93Lix/Q
share_updated: 2025-02-13T16:45:45+08:00
---

### 1. 初始化

设备号 `dev` 分配：
- 主设备号区分设备驱动类型，次设备号区分同种驱动设备不同个体

分配方式：
- 静态分配：开发者自己设定主设备号数字，然后通过函数 `register_chrdev_region` 向内核申请使用
- 动态分配：通过 `alloc_chrdev_region` 函数由内核进行分配可用主设备号

设备号是一种资源，驱动退出后需释放

### 2. ops：操作函数集

`file_operations` 是一个函数指针的的集合，定义能在设备上进行的操作。结构中的指针指向驱动中的操作函数，通过这些函数即可实现对设备的操作，对不支持的操作指针设置为 BULL

### 3. 设备分类：

- 字符设备：以字节流方式进行数据传输的设备。如键盘等
- 块设备：以"数据块 (block)"方式进行传输的设备。如硬盘，SD 卡等。
- 网络设备：如网卡等.
- .........

### 4.  设备驱动初始化流程：

- 创建实例，为设备分配内存空间
```c
struct cdev mdev						// 创建一个字符设备实例
struct cdev *pdev = cdev_alloc() 		// 动态分配主设备号
```

- 初始化
设备 `struct cdev` 的初始化通过 `cdev_init` 函数实现，主要是对设备的设备信息以及可用操作函数进行初始化
```c
cdev_init(struct cdev *cdev, const struct file_operations *fops)
```
`cdev`：待初始化的设备信息结构体
`fops`：设备对应的操作函数集

- 注册设备：
字符设备注册通过 `cdev_add()` 函数来实现。

- 硬件初始化：
通过查阅硬件相应的数据手册来实现。


### 5. 设备操作

主要函数：

```c
open()			// 打开设备驱动文件
release()		// 关闭设备驱动文件,有时也叫close()
read()			// 读取设备数据
write()			// 向设备写入数据
```

以上函数函数指针指向结构体类型：

``` c
int (*open)(struct inode *, struct file *)
int (*release)(struct inode *, struct file *)
```

其中涉及到 `inode` 和 `file` 两个结构体类型：
- `inode`：该结构体中主要成员为：设备号 `cdev`, 以便指向需打开或关闭的设备文件
- `file`：该结构体中主要成员包括，文件读写指针 `f_ops` 以及该文件操作行为结构体 `*f_op`

每个存在于文件系统中的文件（设备文件 `cdev`）都会关联一个 `inode` 结构体，在进行 `open` 以及 `release` 操作时，内核会进行 `file` 结构体关联，即，`file` 结构体会在文件被内核打开时创建，在关闭时释放。

`open()` 设备方法完成的工作：标记次设备号，启动设备，`release()` 设备方法与之相反

``` c
ssize_t (*read)(struct file *filp, char __user *buff, size_t count, loff_t *offp)
ssize_t (*write)(struct file *filp, const char __user *buff, size_t count, loff_t *offp)
```

- `filp`：与字符设备文件关联的 `file` 结构指针，由内核创建
- `buff`：从设备读取到的数据进行保存的位置
- `cout`：请求传输的数据量
- `offp`：文件的读写位置（文件偏移量指针），由内核从 `file` 结构体中取出后传递进来
	- `offp` 作为参数传入，实际上等同于 `filp -> f_pos`，这样子的设计的作用：允许文件操作函数 `read()` 修改文件偏移量，以适应不同的文件访问模式，提高灵活性

> [!Tip] `buff` 不能直接被内核代码引用
> `buff` 参数来源于用户空间，在 `Linux` 内核下，用户空间与内核空间是区分开的
> - 用户空间：运行普通程序，不能直接访问内核数据
> - 内核空间：运行内核程序以及驱动程序，不能直接访问用户数据

需要使用 `copy_to_user()` 和 `copy_from_user()` 这两个专门的函数进行数据传输。

``` c
int copy_to_user(void __user *to, const void *from, int n)		// 将内核数据发送到用户空间
int copy_from_user(void *to, const void __user *from, int n)	// 将用户数据发送到内核空间

// char kernel_buffer[100] = "Hello from kernel!";
// copy_to_user(user_buffer, kernel_buffer, sizeof(kernel_buffer));
```

### 6. 驱动注销：

在内核中卸载驱动程序时，可以通过 `cdev_del` 函数来实现字符设备的注销




