---
share_link: https://share.note.sx/chxq8m7e#1vyer6fOkRGCHDMds4MHL355o1ipucyPuuJRVDEAkgE
share_updated: 2025-02-13T16:46:07+08:00
---
### 1. 硬中断以及软中断：

#### 1.1 硬中断：

- 硬件中断是由**硬件产生**的，比如磁盘、网卡、时钟等，每个设备或设备集都有其自己的 `IRQ`（interrupt request）。根据 `IRQ`，CPU 可将相应的请求分发到对应的硬件驱动上

> [!Tip] 硬件驱动进程
> 硬件驱动通常是运行在**内核空间（Kernel Space）**的代码，它作为**内核的一个子程序**，与内核共享相同的地址空间
> 
> 驱动程序是内核的一部分：
> - 他不是一个单独的用户态进程，而是嵌入到内核中的代码，作为一个函数库或模块提供服务
> - 驱动程序为用户态程序提供接口，通常是通过系统调用（或设备文件等机制）来实现。用户态程序不能直接操作硬件，而是通过调用这些接口，由操作系统内核来转发请求给相应的驱动，从而间接地操作硬件。

- 处理中断的驱动是需要运行在 CPU 上的，当产生中断时，CPU 检测到中断信号，会中断正在运行的任务，保存当前 CPU 状态，跳转到中断向量表 （IVT）中查找对应的中断处理程序（ISR interrupt service routine）来执行中断程序。程序执行完毕后 CPU 会恢复之前保存的状态，执行原来的任务

> [!Tip] 中断与 CPU
> 在多核心的系统上，一个中断通常只能中断一颗 CPU（也存在一种特殊情况，在大型主机上是有硬件通道的，它可以在没有主 CPU 的支持下，同时处理多个中断）

- 对于时钟中断，内核调度代码会将正在运行的进程挂起，从而让其他的进程来运行，它的存在是为了让调度器可以调度多任务

> [!Note] 时钟中断与进程调度
> 由于 CPU 需要在多个进程之间切换运行 （即多任务调度）, 系统需要一个定期打断正在运行的进程，让操作系统的调度器有机会决定是否切换到另一个进程，这个机制就是**时钟中断**
> 
> **时钟中断**是由硬件定时器周期性触发的中断，它会定期打断 CPU，通知内核执行调度任务，即：
> - 检查当前进程时间片是否用完
> - 决定是否切换到另一个进程
> 	- 调用调度器选择下一个应该运行的进程
> 	- 保存当前进程 CPU 状态，切换到新进程
> - 更新系统时间

#### 1.2 软中断：

- 软中断的处理方式与硬中断相同，但他是由当前正在运行的进程产生
- 软中断通常用来处理与外部设备进行数据交换的请求 , 与硬中断不同，软中断一般由内核内部触发，用于调度或处理与 I/O 相关的任务。
	- 当软中断被触发时，内核会启动一段程序来进行 I/O 的操作执行，即通过软中断，内核能够进行管理和安排设备的 I/O 操作
- **对于某些设备（例如网络设备或实时设备），其 `I/O` 请求需要立即被处理，而磁盘 `I/O` 请求可以通过队列机制来优化整体效率，即可以先排队并且稍后处理**。
- 根据 `I/O` 模型的不同，在某些模型（例如阻塞 `I/O` 模型）中，发起 `I/O` 操作的进程如果等待时间过长，会被挂起直到 `I/O` 操作完成，此时，当进程处于挂起状态时，内核调度器就会将 CPU 分配给其他处于就绪状态的进程运行。

```
软中断 --> I/O请求 ——(当前I/O未阻塞)-> 执行 I/O 操作
			|
			|--(当前I/O阻塞)--> 挂起等待 ----> 分配CPU给其他进程运行
```

- 软中断并不会直接中断 CPU，只有当前正在运行的代码 (或进程) 会产生软中断

#### 1.3 二者区别：

1. 软中断是执行中断指令产生的，而硬中断是由外设引发的
2. 硬中断的中断号是由中断控制器提供的，软中断的中断号是由指令直接指出，无需中断控制器
3. 硬中断可屏蔽，软中断不可屏蔽
4. 硬中断处理程序需要确保它能快速地完成任务，避免阻塞其他中断响应以及正常进程的运行，属于上半部
5. 软中断处理硬中断未完成的工作，是一种推后执行的机制，属于下半部

### 1.4 中断上半部和下半部

在 Linux 内核中，为了兼顾对硬件中断的快速响应以及对后续处理任务的充分执行，采用 "中断上下半部" 的机制。即将中断处理拆分为两部分：
- 上半部：负责迅速响应中断，完成与硬件交互的必要工作
- 下半部：负责延迟处理那些不必马上完成但仍需要处理的任务

> [!NOTE] 下半部实现机制
> （1）软中断：
> - 特点：由内核提供的一种轻量级下半部机制
> - 适用：用于处理频繁、简单且对实时性要求较高的任务，如网络数据包处理
> - 执行环境：软中断在固定的内核上下文中执行，具有较高的优先级，并且通常是在中断返回后立即处理
>   
> （2）任务队列（`Tasklet`）：
> - 特点：任务队列是建立在软中断之上的一种抽象，提供更简单的编程接口
> - 使用：用于延迟执行稍微复杂一些但依然要求快速处理的任务
> - 执行特点：`Tasklet` 是串行化执行的，也就是说同一个 `tasklet` 在任一时刻只会运行一次，但不同 `tasklet` 之间可以并行运行
> 
> （3）工作队列（`workqueue`）：
> - 特点：工作队列允许将任务放到一个内核线程中执行，这样可以在进程上下文中运行下半部
> - 适用：使用与一些需要休眠或进行阻塞性操作的任务 (例如，文件操作)
> - 执行环境：由于运行在进程上下文中，工作队列中的任务可以调用许多常规的内核函数

> [!note] 上下文
> 在操作系统中，“上下文”（context）通常指的是当前执行环境的状态信息，包括：
> - **CPU 寄存器**（例如程序计数器、栈指针、通用寄存器等）
> - **内存映射**（当前进程的虚拟地址空间、数据段、堆栈等）
> - **进程状态信息**（进程描述符、权限、调度信息等）
> - 调度信息（调度优先级、时间片等）
>   
> 操作系统内核会定期保存和恢复这些上下文信息，以便在发生线程切换时能够正确恢复线程的执行状态。这个过程就称为
>   
> 上下文决定了当前代码执行时的环境和资源访问权限。根据代码执行的场景不同，我们常常将上下文分为：
> - **进程上下文（Process Context）：**  
>   表示代码执行是在某个进程（或线程）的环境中。此时，该执行单元拥有完整的进程属性，能进行系统调用、可以睡眠（阻塞）、访问用户空间内存等操作。大多数内核函数都要求在进程上下文中调用。
> 
> - **中断上下文（Interrupt Context）：** 
>    当 CPU 响应硬件中断时，会进入中断上下文。此时执行的中断处理程序（ISR，上半部）不能睡眠、阻塞或进行长时间操作，因为它们运行在一种临时且受限的环境中。中断上下文仅限于快速响应和完成必要的硬件交互。
>  
>  - **软中断/Tasklet 上下文：**  
>    虽然严格来说它们也属于内核中断处理的一部分，但与硬件中断处理（上半部）相比，它们是延迟执行的下半部，但仍然运行在一种类似中断的上下文中，通常也不能调用可能会阻塞的操作。
>    
> 不同的上下文对内核操作有严格限制


**中断流程：**
- 当中断发生时，CPU 会暂停当前执行的任务，切换到内核中断上下文，立即执行对应设备的中断处理程序。
- 上半部迅速识别中断来源，处理必要的硬件交互，清除中断标志等。如果发现有需要延迟的处理工作（如数据处理，后续响应等），则通过调用软中断、`tasklet` 或工作队列的接口，将这些工作挂起
- 在中断处理完成并返回后，内核调度器会在适当的时机（系统空闲或达到一定的调度条件时）执行已经挂起的下半部任务
- 下半部在适合的上下文中运行，完成那些较耗时的处理工作，保证整个中断处理过程既及时又不影响系统的整体性能。